name: Dependabot Slack Notification

on:
  schedule:
    # critical/high: æ¯æ—¥ 9:00 JST (0:00 UTC)
    - cron: "0 0 * * *"
    # medium: æ¯é€±æœˆæ›œ 9:00 JST
    - cron: "0 0 * * 1"
    # low: æ¯æœˆ1æ—¥ 9:00 JST
    - cron: "0 0 1 * *"
  workflow_dispatch:
    inputs:
      severity_filter:
        description: "é€šçŸ¥ã™ã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ« (all / critical / high / medium / low)"
        required: false
        default: "all"

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch Dependabot alerts and notify Slack
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');

            // --------------- è¨­å®š ---------------
            // ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ« or æ‰‹å‹•å…¥åŠ›ã§ãƒ•ã‚£ãƒ«ã‚¿ã‚’æ±ºå®š
            const severityOrder = ['critical', 'high', 'medium', 'low'];

            function getSeverityFilter() {
              // workflow_dispatch ã®å ´åˆ
              const input = context.payload.inputs?.severity_filter;
              if (input) return input;

              // schedule ã®å ´åˆ: cron ã®å€¤ã§åˆ¤å®š
              const cron = context.payload.schedule;
              if (cron === '0 0 * * *')  return 'critical,high';   // æ¯æ—¥
              if (cron === '0 0 * * 1')  return 'medium';          // æ¯é€±
              if (cron === '0 0 1 * *')  return 'low';             // æ¯æœˆ
              return 'all';
            }

            const filterStr = getSeverityFilter();
            const allowedSeverities = filterStr === 'all'
              ? severityOrder
              : filterStr.split(',').map(s => s.trim());

            // --------------- Ignore ãƒªã‚¹ãƒˆèª­ã¿è¾¼ã¿ ---------------
            let ignoredAlerts = [];
            try {
              const raw = fs.readFileSync('.github/dependabot-slack-ignore.json', 'utf8');
              ignoredAlerts = JSON.parse(raw).ignored_alerts || [];
            } catch (_) {
              // ãƒ•ã‚¡ã‚¤ãƒ«ãŒç„¡ã‘ã‚Œã°ç„¡è¦–
            }

            // --------------- ã‚¢ãƒ©ãƒ¼ãƒˆå–å¾— ---------------
            let alerts = [];
            try {
              const res = await github.rest.dependabot.listAlertsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
              });
              alerts = res.data;
            } catch (e) {
              core.warning(`Dependabot alerts ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}`);
              return;
            }

            if (alerts.length === 0) {
              core.info('ã‚ªãƒ¼ãƒ—ãƒ³ãª Dependabot ã‚¢ãƒ©ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚');
              return;
            }

            // --------------- ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° ---------------
            const filtered = alerts.filter(a => {
              const severity = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';

              // severity ãƒ•ã‚£ãƒ«ã‚¿
              if (!allowedSeverities.includes(severity)) return false;

              // ignore ãƒªã‚¹ãƒˆ (GHSA ID ã¾ãŸã¯ã‚¢ãƒ©ãƒ¼ãƒˆç•ªå·ã§é™¤å¤–)
              const ghsaId = a.security_advisory?.ghsa_id || '';
              if (ignoredAlerts.includes(ghsaId)) return false;
              if (ignoredAlerts.includes(a.number)) return false;

              return true;
            });

            if (filtered.length === 0) {
              core.info(`å¯¾è±¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ« (${filterStr}) ã®ã‚¢ãƒ©ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`);
              return;
            }

            // --------------- Slack ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ§‹ç¯‰ ---------------
            const severityEmoji = {
              critical: 'ğŸ”´',
              high:     'ğŸŸ ',
              medium:   'ğŸŸ¡',
              low:      'ğŸ”µ',
            };

            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;

            const lines = filtered.map(a => {
              const sev = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';
              const emoji = severityEmoji[sev] || 'âšª';
              const pkg = a.security_vulnerability?.package?.name || 'unknown';
              const summary = a.security_advisory?.summary || 'No summary';
              const url = a.html_url;
              return `${emoji} *[${sev.toUpperCase()}]* <${url}|#${a.number}> \`${pkg}\` - ${summary}`;
            });

            // severity ã”ã¨ã®ä»¶æ•°ã‚µãƒãƒª
            const counts = {};
            filtered.forEach(a => {
              const sev = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';
              counts[sev] = (counts[sev] || 0) + 1;
            });
            const countSummary = Object.entries(counts)
              .sort(([a], [b]) => severityOrder.indexOf(a) - severityOrder.indexOf(b))
              .map(([sev, n]) => `${severityEmoji[sev] || 'âšª'} ${sev}: ${n}`)
              .join('  |  ');

            const payload = {
              blocks: [
                {
                  type: 'header',
                  text: {
                    type: 'plain_text',
                    text: `ğŸ”’ Dependabot Security Alerts (${filtered.length} ä»¶)`,
                  },
                },
                {
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*Repo:* <${repoUrl}|${context.repo.owner}/${context.repo.repo}>\n*Filter:* ${filterStr}\n*Summary:* ${countSummary}`,
                  },
                },
                { type: 'divider' },
                {
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: lines.join('\n'),
                  },
                },
              ],
            };

            // --------------- Slack é€ä¿¡ ---------------
            const webhookUrl = process.env.SLACK_WEBHOOK_URL;
            if (!webhookUrl) {
              core.setFailed('SLACK_WEBHOOK_URL ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
              return;
            }

            const resp = await fetch(webhookUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });

            if (!resp.ok) {
              core.setFailed(`Slack é€ä¿¡å¤±æ•—: ${resp.status} ${await resp.text()}`);
            } else {
              core.info(`Slack ã« ${filtered.length} ä»¶ã®ã‚¢ãƒ©ãƒ¼ãƒˆã‚’é€šçŸ¥ã—ã¾ã—ãŸã€‚`);
            }
