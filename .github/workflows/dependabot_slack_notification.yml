name: Dependabot Slack Notification (Reusable)

on:
  workflow_call:
    inputs:
      severity_filter:
        description: "é€šçŸ¥ã™ã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ« (ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š: critical,high,medium,low / all)"
        required: true
        type: string
      mention:
        description: "Slack ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å…ˆ (ä¾‹: @channel, @here, <@U12345>, <!subteam^S12345>)"
        required: false
        type: string
        default: ""
    secrets:
      SLACK_WEBHOOK_URL:
        required: true
      DEPENDABOT_TOKEN:
        required: true

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse ignore list
        id: ignore
        run: |
          FILE=".github/dependabot-slack-ignore.yml"
          if [ -f "$FILE" ]; then
            echo "json=$(yq -o=json '.' "$FILE")" >> "$GITHUB_OUTPUT"
          else
            echo 'json={"ignored_alerts":[]}' >> "$GITHUB_OUTPUT"
          fi

      - name: Fetch Dependabot alerts and notify Slack
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SEVERITY_FILTER: ${{ inputs.severity_filter }}
          MENTION: ${{ inputs.mention }}
          IGNORE_LIST_JSON: ${{ steps.ignore.outputs.json }}
        with:
          github-token: ${{ secrets.DEPENDABOT_TOKEN }}
          script: |
            const severityOrder = ['critical', 'high', 'medium', 'low'];
            const filterStr = process.env.SEVERITY_FILTER || 'all';
            const allowedSeverities = filterStr === 'all'
              ? severityOrder
              : filterStr.split(',').map(s => s.trim());

            // --------------- Ignore ãƒªã‚¹ãƒˆèª­ã¿è¾¼ã¿ ---------------
            let ignoredAlerts = [];
            try {
              const ignoreData = JSON.parse(process.env.IGNORE_LIST_JSON || '{}');
              const entries = ignoreData.ignored_alerts || [];
              for (const entry of entries) {
                if (!entry.id || !entry.reason) {
                  core.setFailed(`Ignore list ã®ã‚¨ãƒ³ãƒˆãƒªã« id ã¨ reason ã¯å¿…é ˆã§ã™: ${JSON.stringify(entry)}`);
                  return;
                }
                ignoredAlerts.push(String(entry.id));
              }
            } catch (e) {
              core.setFailed(`Ignore list ã® JSON ãƒ‘ãƒ¼ã‚¹ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}`);
              return;
            }

            // --------------- ã‚¢ãƒ©ãƒ¼ãƒˆå–å¾— ---------------
            let alerts = [];
            try {
              const res = await github.rest.dependabot.listAlertsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
              });
              alerts = res.data;
            } catch (e) {
              core.setFailed(`Dependabot alerts ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}`);
              return;
            }

            if (alerts.length === 0) {
              core.info('ã‚ªãƒ¼ãƒ—ãƒ³ãª Dependabot ã‚¢ãƒ©ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚');
              return;
            }

            // --------------- ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° ---------------
            const filtered = alerts.filter(a => {
              const severity = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';

              if (!allowedSeverities.includes(severity)) return false;

              const ghsaId = a.security_advisory?.ghsa_id || '';
              if (ghsaId && ignoredAlerts.includes(ghsaId)) return false;
              if (ignoredAlerts.includes(String(a.number))) return false;

              return true;
            });

            if (filtered.length === 0) {
              core.info(`å¯¾è±¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ« (${filterStr}) ã®ã‚¢ãƒ©ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`);
              return;
            }

            // --------------- Slack ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ§‹ç¯‰ ---------------
            const severityEmoji = {
              critical: 'ğŸ”´',
              high:     'ğŸŸ ',
              medium:   'ğŸŸ¡',
              low:      'ğŸ”µ',
            };

            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;

            const lines = filtered.map(a => {
              const sev = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';
              const emoji = severityEmoji[sev] || 'âšª';
              const pkg = a.security_vulnerability?.package?.name || 'unknown';
              const summary = a.security_advisory?.summary || 'No summary';
              const url = a.html_url;
              return `${emoji} *[${sev.toUpperCase()}]* <${url}|#${a.number}> \`${pkg}\` - ${summary}`;
            });

            const counts = {};
            filtered.forEach(a => {
              const sev = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';
              counts[sev] = (counts[sev] || 0) + 1;
            });
            const countSummary = Object.entries(counts)
              .sort(([a], [b]) => severityOrder.indexOf(a) - severityOrder.indexOf(b))
              .map(([sev, n]) => `${severityEmoji[sev] || 'âšª'} ${sev}: ${n}`)
              .join('  |  ');

            const mention = (process.env.MENTION || '').trim();

            const payload = {
              blocks: [
                {
                  type: 'header',
                  text: {
                    type: 'plain_text',
                    text: `ğŸ”’ Dependabot Security Alerts (${filtered.length} ä»¶)`,
                  },
                },
                ...(mention ? [{
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: mention,
                  },
                }] : []),
                {
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*Repo:* <${repoUrl}|${context.repo.owner}/${context.repo.repo}>\n*Filter:* ${filterStr}\n*Summary:* ${countSummary}`,
                  },
                },
                { type: 'divider' },
                ...(() => {
                  const joined = lines.join('\n');
                  if (joined.length <= 3000) {
                    return [{ type: 'section', text: { type: 'mrkdwn', text: joined } }];
                  }
                  // Split into multiple sections within 3000 char limit
                  const sections = [];
                  let current = '';
                  for (const line of lines) {
                    if (current && (current + '\n' + line).length > 3000) {
                      sections.push({ type: 'section', text: { type: 'mrkdwn', text: current } });
                      current = line;
                    } else {
                      current = current ? current + '\n' + line : line;
                    }
                  }
                  if (current) {
                    sections.push({ type: 'section', text: { type: 'mrkdwn', text: current } });
                  }
                  return sections;
                })(),
              ],
            };

            // --------------- Slack é€ä¿¡ ---------------
            const webhookUrl = process.env.SLACK_WEBHOOK_URL;
            if (!webhookUrl) {
              core.setFailed('SLACK_WEBHOOK_URL ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
              return;
            }

            let resp;
            try {
              resp = await fetch(webhookUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
              });
            } catch (e) {
              core.setFailed(`Slack é€ä¿¡ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ${e.message}`);
              return;
            }

            if (!resp.ok) {
              core.setFailed(`Slack é€ä¿¡å¤±æ•—: ${resp.status} ${await resp.text()}`);
            } else {
              core.info(`Slack ã« ${filtered.length} ä»¶ã®ã‚¢ãƒ©ãƒ¼ãƒˆã‚’é€šçŸ¥ã—ã¾ã—ãŸã€‚`);
            }
