name: Dependabot Slack Notification (Reusable)

on:
  workflow_call:
    inputs:
      severity_filter:
        description: "é€šçŸ¥ã™ã‚‹ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ« (ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š: critical,high,medium,low / all)"
        required: true
        type: string
      mention:
        description: "Slack ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å…ˆ (ä¾‹: @channel, @here, <@U12345>, <!subteam^S12345>)"
        required: false
        type: string
        default: ""
    secrets:
      SLACK_WEBHOOK_URL:
        required: true
      DEPENDABOT_TOKEN:
        required: true

jobs:
  notify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch Dependabot alerts and notify Slack
        uses: actions/github-script@v7
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SEVERITY_FILTER: ${{ inputs.severity_filter }}
          MENTION: ${{ inputs.mention }}
        with:
          github-token: ${{ secrets.DEPENDABOT_TOKEN }}
          script: |
            const fs = require('fs');

            const severityOrder = ['critical', 'high', 'medium', 'low'];
            const filterStr = process.env.SEVERITY_FILTER || 'all';
            const allowedSeverities = filterStr === 'all'
              ? severityOrder
              : filterStr.split(',').map(s => s.trim());

            // --------------- Ignore ãƒªã‚¹ãƒˆèª­ã¿è¾¼ã¿ ---------------
            let ignoredAlerts = [];
            try {
              const raw = fs.readFileSync('.github/dependabot-slack-ignore.json', 'utf8');
              const parsed = JSON.parse(raw).ignored_alerts || [];
              ignoredAlerts = parsed.map(entry => {
                if (typeof entry === 'object' && entry !== null) {
                  if (!entry.id || !entry.reason) {
                    core.warning(`Ignore list ã®ã‚¨ãƒ³ãƒˆãƒªã« id ã¾ãŸã¯ reason ãŒã‚ã‚Šã¾ã›ã‚“: ${JSON.stringify(entry)}`);
                  }
                  return String(entry.id);
                }
                return String(entry);
              });
            } catch (e) {
              if (e.code !== 'ENOENT') {
                core.warning(`Ignore list ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}`);
              }
            }

            // --------------- ã‚¢ãƒ©ãƒ¼ãƒˆå–å¾— ---------------
            let alerts = [];
            try {
              const res = await github.rest.dependabot.listAlertsForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
              });
              alerts = res.data;
            } catch (e) {
              core.setFailed(`Dependabot alerts ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ: ${e.message}`);
              return;
            }

            if (alerts.length === 0) {
              core.info('ã‚ªãƒ¼ãƒ—ãƒ³ãª Dependabot ã‚¢ãƒ©ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚');
              return;
            }

            // --------------- ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚° ---------------
            const filtered = alerts.filter(a => {
              const severity = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';

              if (!allowedSeverities.includes(severity)) return false;

              const ghsaId = a.security_advisory?.ghsa_id || '';
              if (ghsaId && ignoredAlerts.includes(ghsaId)) return false;
              if (ignoredAlerts.includes(String(a.number))) return false;

              return true;
            });

            if (filtered.length === 0) {
              core.info(`å¯¾è±¡ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ™ãƒ« (${filterStr}) ã®ã‚¢ãƒ©ãƒ¼ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“ã€‚`);
              return;
            }

            // --------------- Slack ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æ§‹ç¯‰ ---------------
            const severityEmoji = {
              critical: 'ğŸ”´',
              high:     'ğŸŸ ',
              medium:   'ğŸŸ¡',
              low:      'ğŸ”µ',
            };

            const repoUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}`;

            const lines = filtered.map(a => {
              const sev = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';
              const emoji = severityEmoji[sev] || 'âšª';
              const pkg = a.security_vulnerability?.package?.name || 'unknown';
              const summary = a.security_advisory?.summary || 'No summary';
              const url = a.html_url;
              return `${emoji} *[${sev.toUpperCase()}]* <${url}|#${a.number}> \`${pkg}\` - ${summary}`;
            });

            const counts = {};
            filtered.forEach(a => {
              const sev = a.security_vulnerability?.severity?.toLowerCase()
                || a.security_advisory?.severity?.toLowerCase()
                || 'unknown';
              counts[sev] = (counts[sev] || 0) + 1;
            });
            const countSummary = Object.entries(counts)
              .sort(([a], [b]) => severityOrder.indexOf(a) - severityOrder.indexOf(b))
              .map(([sev, n]) => `${severityEmoji[sev] || 'âšª'} ${sev}: ${n}`)
              .join('  |  ');

            const mention = (process.env.MENTION || '').trim();

            const payload = {
              blocks: [
                {
                  type: 'header',
                  text: {
                    type: 'plain_text',
                    text: `ğŸ”’ Dependabot Security Alerts (${filtered.length} ä»¶)`,
                  },
                },
                ...(mention ? [{
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: mention,
                  },
                }] : []),
                {
                  type: 'section',
                  text: {
                    type: 'mrkdwn',
                    text: `*Repo:* <${repoUrl}|${context.repo.owner}/${context.repo.repo}>\n*Filter:* ${filterStr}\n*Summary:* ${countSummary}`,
                  },
                },
                { type: 'divider' },
                ...(() => {
                  const joined = lines.join('\n');
                  if (joined.length <= 3000) {
                    return [{ type: 'section', text: { type: 'mrkdwn', text: joined } }];
                  }
                  // Split into multiple sections within 3000 char limit
                  const sections = [];
                  let current = '';
                  for (const line of lines) {
                    if (current && (current + '\n' + line).length > 3000) {
                      sections.push({ type: 'section', text: { type: 'mrkdwn', text: current } });
                      current = line;
                    } else {
                      current = current ? current + '\n' + line : line;
                    }
                  }
                  if (current) {
                    sections.push({ type: 'section', text: { type: 'mrkdwn', text: current } });
                  }
                  return sections;
                })(),
              ],
            };

            // --------------- Slack é€ä¿¡ ---------------
            const webhookUrl = process.env.SLACK_WEBHOOK_URL;
            if (!webhookUrl) {
              core.setFailed('SLACK_WEBHOOK_URL ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚');
              return;
            }

            const resp = await fetch(webhookUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload),
            });

            if (!resp.ok) {
              core.setFailed(`Slack é€ä¿¡å¤±æ•—: ${resp.status} ${await resp.text()}`);
            } else {
              core.info(`Slack ã« ${filtered.length} ä»¶ã®ã‚¢ãƒ©ãƒ¼ãƒˆã‚’é€šçŸ¥ã—ã¾ã—ãŸã€‚`);
            }
